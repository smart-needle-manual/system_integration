1. Once we do . install/setup.bash, we can see /IGTL_POINT_OUT and /IGTL_STRING_OUT to Slicer, but not /IGTL_POINT_IN and /IGTL_STRING_IN from Slicer. Why?
Ans: Because of the topic publishers and their data types. Let's consider, first, the structure of the /IGTL_*_OUT messages. 

ros2 topic echo /IGTL_STRING_OUT name: NeedleShapeHeader data: 2025-10-24 09:43:37.811;303;402;zFrame --- 
ros2 topic echo /IGTL_POINT_OUT name: NeedleShapeZ pointdata: - x: 0.0 y: 0.0 z: 200.0 - x: 0.0 y: 0.0 z: 200.00000000167904 - x: -3.093342991866126e-06 y: -1.2461235326727167e-05 z: 200.5000000015142 - '...'

We have here a data stream out on /IGTL_STRING_OUT and /IGTL_POINT_OUT, the first a header message containing timestamp and identifiers, and the second a 3D curve message with a pointdata array of (x,y,z) coordinates describing the reconstructed shape of a needle.

In the example with the DEFAULT MESSAGE from system integration, the NeedleShapeZ sample is a series of point sampled along the needle's length, starting at z = 200 mm and increasing to around 262 mm, while the x and y drift gradually negative, meaning the needle bends smoothly in a particular direction.

Looking at the igtl_node.cpp in ros2_igtl_bridge, which takes in /IGTL_*_OUT, the internal structure is not changed. Note that the /IGTL_*_IN topics cannot be echoed because they ar einput topics consumed by the bridge rather than normal ROS message topics with a known message type being published by a ROS node.
They are dynamically created subscriptions by the bridge to receive messages you want to send to Slicer, not publishers.

So, /IGTL_*_OUT is published by ROS and sent to Slicer. /IGTL_*_IN is subscribed by ROS and received from Slicer. Since we are not publishing anything on /IGTL_*_IN inside ROS, there is no message in the ROS ecosystem to echo, even though the bridge itself forwards network data to Slicer over the OpenIGTLink socket.

On the backend, this->converterManager->AddConverter(string, 10, "IGTL_STRING_IN", "IGTL_STRING_OUT");
this->converterManager->AddConverter(pointarray, 10, "IGTL_POINT_IN", "IGTL_POINT_OUT");

, with each AddConverter call registering a ROS publisher for the _OUT topic, a ROS subscription for the _IN topic, and an OpenIGTLink message type handler that knows how to serialize/deserialize OpenIGTLink packets.

| Direction | ROS Topic         | Role                                        | Seen by ROS2 tools        | Seen by Slicer                     |
| --------- | ----------------- | ------------------------------------------- | ------------------------- | ---------------------------------- |
| OUT       | `/IGTL_POINT_OUT` | Publishes `ros2_igtl_bridge/msg/PointArray` | âœ… yes (`ros2 topic echo`) | âœ… yes                              |
| IN        | `/IGTL_POINT_IN`  | Subscribes for same type                    | ðŸš« no (not published)     | âœ… yes (Slicer sends updates to it) |

When we see the needle in Slicer, that is because Slicer is reading the /IGTL_POINT_OUT data, the outgoing message. Slicer's own messages would come bcak into /IGTL_POINT_IN, but those don't appear as ROS publications unless another ROS node publishes them.

In terms of seeing what Slicer sees, topic echo of /IGTL_*_OUT is for the data Slicer receives and uses to render the needle.

To see what is being recieved from Slicer, the igtl_node.cpp would need to be modified to include for example a publisher republishing /IGTL_POINT_IN data once received by the converter, e.g.:

// Inside RIBConverterPointArray::ReceiveIGTLMessage(...)
// after deserializing the IGTL data:
publisher_->publish(ros_msg);  // republish the converted message

Another option is to log it directly to the console in ProcessIGTLMessage.

| Topic              | Purpose                              | Why `ros2 topic echo` fails | What Slicer â€œseesâ€   |
| ------------------ | ------------------------------------ | --------------------------- | -------------------- |
| `/IGTL_STRING_OUT` | Outgoing string header to Slicer     | âœ… works (you can echo)      | âœ… Slicer reads it    |
| `/IGTL_POINT_OUT`  | Outgoing needle geometry to Slicer   | âœ… works (you can echo)      | âœ… Slicer reads it    |
| `/IGTL_STRING_IN`  | Incoming string messages from Slicer | ðŸš« subscriber only          | âœ… Slicer writes here |
| `/IGTL_POINT_IN`   | Incoming point data from Slicer      | ðŸš« subscriber only          | âœ… Slicer writes here |

To verify latency, add metadata, or add new OpenIGTLink message types, these will be done in the converter layer.

2. Let's take a look at what Slicer does with the NeedleShapeZ data once it receives it, specifically how it renders or updates the MRML node. Let's also consider how perhaps in the Markups module one would manually publish such topic information in Slicer.

Inside Slicer, all OpenIGTLink communication is managed through the OpenIGTLinkIF module. It creates connector nodes which are network bridges between Slicer's MRML scene and an external device or program like ros2_igtl_bridge.

Each connector can be a server mode which waits for a connection from ROS, or a Client mod connecting out to ROS (bridge).
Each connector can either send (from Slicer externally) MRML nodes, or receive MRML nodes. That mapping correspondings to /IGTL_*_IN and /IGTL_*OUT topics, respectively.

The Markups module (Markups Fiducials*, Curve, or Line) creates MRML nodes like vtkMRMLMarkupsFiducialNode and vtkMRMLMarkupsCurveNode. These can contain lists of 3D points, e.g. /IGTL_POINT_OUT data type.

3. Studying the information flow.
From shape_sensing_needle.py, we get the ShapeSensingNeedleNode, a ROS2 node that reconstructs the current needle shape from sensor data and publishes it as a geometry_msgs/PoseArray on the topic /state/current_shape.

The essential components of that big file are below:

in publish_shape():
pmat, Rmat = self.get_needleshape()     # Nx3 positions and Nx3x3 rotations
header = Header(stamp=..., frame_id='needle')
msg_shape = utilities.poses2msg(pmat, Rmat, header=header)
self.pub_shape.publish(msg_shape)

So that each mesage looks like:
geometry_msgs/msg/PoseArray
  header:
    frame_id: "needle"
  poses:
    - position: {x: ..., y: ..., z: ...}
      orientation: {x: ..., y: ..., z: ..., w: ...}
    - ...

This is exactly the 3D curve along the needle, sampled at some ds spacing.

ROS2 --> OpenIGTLink has to map this PoseArray into an IGTL-compatible format, since Slicer doesn't understand PoseArray directly. It expects IGTL messages like POINT for Markups/Fiducials/Curves, STRING (metadata/headers), TRANSFORM, IMAGE, etc.

Hence, the /IGTL_POINT_OUT topic and /IGTL_STRING_OUT serve as the translation layer between this /state/current_shape and what Slicer visualizes.

From dummy_smart_needle_interface.py, we get a SmartNeedleInterface node which is a bridge sitting between ROS2 and the OpenIGTLink bridge (igtl_node.cpp).

It subscribes to /needle/state/current_shape [geometry_msgs/PoseArray], extracts and reformats that datat into two IGTL-friendly messages:

String message IGTL_STRING_OUT carrying a text header with metadata and a PointArray message IGTL_POINT_OUT carrying the actual 3-D curve points.

It publishes both every second via timer_shape_callback so igtl_node.cpp can forward them out through the OpenIGTLink socket to Slicer.

| Topic              | Message type                      | Purpose                                           | What Slicer uses it for                                                          |
| ------------------ | --------------------------------- | ------------------------------------------------- | -------------------------------------------------------------------------------- |
| `/IGTL_STRING_OUT` | `ros2_igtl_bridge/msg/String`     | Metadata: timestamp, sample count, frame ID, etc. | Optional. Some Slicer modules use it to identify or synchronize multi-part data. |
| `/IGTL_POINT_OUT`  | `ros2_igtl_bridge/msg/PointArray` | 3-D coordinates of the reconstructed needle shape | The actual geometry Slicer turns into a Markups Curve.                           |

The igtl_node.cpp bridge has converters for both, so each gets serialized as an OpenIGTLink message (STRING and POINT respectively) and sent over the socket.

Again, structure of the outgoing messages:

IGTL_STRING_OUT:
ros2_igtl_bridge/msg/String
  name: "NeedleShapeHeader"
  data: "2025-10-24 09:43:37.811;303;402;zFrame"
IGTL_POINT_OUT:
ros2_igtl_bridge/msg/PointArray
  name: "NeedleShapeZ"
  pointdata:
    - {x: 0.0,     y: 0.0,     z: 200.0}
    - {x: -0.0036, y: -0.0159, z: 202.02}
    ...

Inside Slicer's OpenIGTLinkIF, when it receives a message named NeedleShapeZ, it creates or updates a Markups Curve node called "NeedleShapeZ" using the points and optionally reads NeedleShapeHeader to annotate the time/frame.
That is how we get the visible bending needle.

---------------------------------------------------------------------------------------------------------------------------------

So far we have the node that publishes /state/current_shape and the node that listens to it and republishes IGTL messages.









