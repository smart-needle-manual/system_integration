Slicer's data model is built around a MRML scene, which is a graph of interconnected nodes. Each item in the Data module, such as subjects, studies, volumes, transforms, markups, modules,
and more is a MRML node. Nodes can reference each other. Examples: A volume node may be transformed by a transform node; a model might reference a scalar overlay volume; a segmentation can reference a master volume.

In the subject hierarchy, the subject is the top-level grouping, usually representing one patient.
Studies are optional layers often used for multiple imaging sessions.
Data nodes such as volumes and models are MRML nodes under the hierarchy.

Each hierarchy item may have references:
Parent/child relationships provide hierarchical organization in the Data tree; transform references define spatial relationships; and other child/parent node references exist,
such as segmentations referencing volumes, or models referencing transforms.

In the transform reference case, if node A is transformed by node B, nodeA's transformID is the ID of node B. When Slicer renders A, it applies transform B automatically.
When you remove a transform node, Slicer checks what nodes reference it; this is where highlighting helps. Highlight color visualizes dependency directionality. 

Green emphasizes items referencing the current item --> Incoming edges
Yellow "  "   "   "  " referenced by "   "  "   "  "  "   Outgoing " "
Light yellow "   "   " recursively referenced by the current item --> Deeper layers -- "What do I indirectly depend on"

Consider the following example:

Subject (Patient)
‚îî‚îÄ‚îÄ Study (Scan session)
     ‚îú‚îÄ‚îÄ Volume1          ‚Üê Data Node (original MRI scan)
     ‚îú‚îÄ‚îÄ Volume2          ‚Üê Data Node (registered MRI scan)
     ‚îú‚îÄ‚îÄ Segmentation1    ‚Üê Data Node (segmentation of Volume2)
     ‚îú‚îÄ‚îÄ Transform1       ‚Üê Transform Node (aligns Volume2 to Volume1)
     ‚îî‚îÄ‚îÄ Transform2       ‚Üê Transform Node (moves Transform1 to world space)

Segmentation1 (Data Node) ‚îÄ‚îÄ‚Üí Volume2 (Data Node) ‚îÄ‚îÄ‚Üí Transform1 (Transform Node) ‚îÄ‚îÄ‚Üí Transform2 (Transform Node)

Subject (Patient)
‚îî‚îÄ‚îÄ Study (Session)
     ‚îú‚îÄ‚îÄ üü© Segmentation1   ‚Üí  üü® Volume2  ‚Üí  üü® Transform1  ‚Üí  üü®‚óå Transform2
     ‚îÇ                          ‚Üë
     ‚îÇ                     Selected node
     ‚îÇ
     ‚îú‚îÄ‚îÄ Volume1  (unrelated, stays gray)
     ‚îî‚îÄ‚îÄ (All under Study)

In this example: Segmentation1 is based on Volume2 (referencing it as its master volume), Volume2 is transformed by Transform1, and Transform1 is transformed by Transform2 (a parent transform).

A plugin is any loadable, extensible component that adds functionality. Internally, msot are implemented as modules in Python or C++, or as plugins within modules.

| Type                                    | Purpose                                                               | Typical Examples                                           |
| --------------------------------------- | --------------------------------------------------------------------- | ---------------------------------------------------------- |
| **Loadable module (C++)**               | Performance-critical processing, visualization, IO                    | Volumes, Models, Segmentations, Transforms                 |
| **Scripted module (Python)**            | Custom logic and UI, fast development                                 | Segment Editor Effects, Registration plugins, AI inference |
| **CLI module (Command-Line Interface)** | Executes external command-line tools with standard I/O                | BRAINS registration, diffusion tools                       |
| **Subject hierarchy plugin**            | Extends how items appear in the Data module and how references behave | Subject hierarchy display rules, node type icons           |
| **DICOM plugin**                        | Adds support for new DICOM modalities or private tags                 | RT, PET, Ultrasound, etc.                                  |
| **Markups / Annotation plugins**        | Add new types of markups (points, curves, planes, ROI)                | Fiducials, Curve, Angle, ROI                               |
| **I/O plugins**                         | Add import/export support for new file formats                        | Custom 3D formats, medical device output                   |
| **Python scripted logic modules**       | Provide backend logic callable from Python                            | e.g., custom pipelines or AI preprocessing steps           |
| Module                | Purpose                                                                                     |
| --------------------- | ------------------------------------------------------------------------------------------- |
| **Data**              | Shows subject hierarchy and MRML nodes; handles references (the one you‚Äôve been analyzing). |
| **DICOM**             | Manages DICOM import/export, database, and plugins.                                         |
| **Transforms**        | Displays and edits transform nodes.                                                         |
| **Subject hierarchy** | Underlying logic for Data module hierarchy organization.                                    |
| Module                             | Purpose                                                  |
| ---------------------------------- | -------------------------------------------------------- |
| **Volumes**                        | Manages scalar and vector volumes, window/level display. |
| **Slice Viewer / 3D Viewer**       | Built-in display controls for visualization.             |
| **Volume Rendering**               | GPU volume rendering controls.                           |
| **Models**                         | Display and manage surface meshes (STL, OBJ, etc.).      |
| **Segmentations / Segment Editor** | Create, edit, and manage segmentation nodes.             |
| Module                                            | Purpose                                  |
| ------------------------------------------------- | ---------------------------------------- |
| **Transforms**                                    | View, edit, and combine transform nodes. |
| **Landmark Registration / Fiducial Registration** | Registration via markups.                |
| **General Registration (BRAINS)**                 | Advanced CLI-based registration.         |
| Module                 | Purpose                                         |
| ---------------------- | ----------------------------------------------- |
| **Label Statistics**   | Compute voxel counts and volumes for labelmaps. |
| **Segment Statistics** | Compute measurements for segmentations.         |
| **PET DICOM tools**    | Quantify SUV and related measures.              |
| Module                          | Purpose                                      |
| ------------------------------- | -------------------------------------------- |
| **Python Interactor**           | Console access to MRML scene and Python API. |
| **Sample Data**                 | Loads example datasets for testing.          |
| **Screen Capture / Animations** | Capture renderings for documentation.        |
| **Application Settings**        | System and display configuration.            |



| **Plugin Type**        | **Purpose / What It Does**                                                                                                | **Implementation (How to Make It)**                                                                                                                                                                                                                                                   | **Defines / Customizes**                                                                                                           | **Examples (Built-in or Extensions)**                                                                                                                                                       |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| üìù **Write Plugin**    | Adds or extends *data writing / export* capabilities for specific node types (e.g., saving special file formats).         | ‚Ä¢ Subclass of `qSlicerSubjectHierarchyAbstractPlugin` (C++) or `AbstractScriptedSubjectHierarchyPlugin` (Python).<br>‚Ä¢ Implement write logic in `writeData()` and define supported node types.<br>‚Ä¢ Register the plugin in the module‚Äôs `setup()` or `__init__()`.                    | ‚Ä¢ File type support<br>‚Ä¢ Export actions in context menu<br>‚Ä¢ Node-to-file mapping rules                                            | *Less common in core; examples appear in extensions that add export formats (e.g., SlicerRT for DICOM-RT, SlicerHeart for cardiac structures)*                                              |
| üß± **Role Plugin**     | Adds *support for new data node types* ‚Äî defines how they appear and behave in the Subject Hierarchy.                     | ‚Ä¢ Subclass `qSlicerSubjectHierarchyAbstractPlugin` (C++) or `AbstractScriptedSubjectHierarchyPlugin` (Python).<br>‚Ä¢ Implement node type ownership (`canOwnSubjectHierarchyItem`), icon, tooltip, visibility handling, help text, and display name.<br>‚Ä¢ Register during module setup. | ‚Ä¢ Ownership rules<br>‚Ä¢ Node icons and tooltips<br>‚Ä¢ Display visibility<br>‚Ä¢ Help text and edit properties<br>‚Ä¢ Displayed node name | **Core:** Markups, Models, SceneViews, Charts, Folder, Tables, Transforms, LabelMaps, Volumes<br>**Extensions:** Role plugin in *SlicerHeart* (cardiac nodes)                               |
| ‚öôÔ∏è **Function Plugin** | Adds *actions* (functions) to the **right-click context menu** for nodes or the scene ‚Äî allows custom operations on data. | ‚Ä¢ Subclass `qSlicerSubjectHierarchyAbstractPlugin` (C++) or `AbstractScriptedSubjectHierarchyPlugin` (Python).<br>‚Ä¢ Implement functions that define context menu actions (`nodeContextMenuActions`), specify applicable node types, and connect actions to logic.                     | ‚Ä¢ Context menu actions<br>‚Ä¢ Scene-level actions<br>‚Ä¢ Node-type filtering for actions<br>‚Ä¢ Action logic handlers                    | **Core:** CloneNode, ParseLocalData, Register, Segment, DICOM, Volumes, Markups, Models, Annotations, Segmentations, Segments<br>**Extensions:** Function plugin in *Segment Editor* module |

Markups Module: Used to create and edit markups (point list, line, angle, curve, closed curve, plane, ROI) and adjust their display properties.

Placing new markups (control points):
1. Toggle the Markups Toolbar in the Mouse Interaction toolbar to show/hide the Markups toolbar.

2. Using Markups toolbar, click markups type buttong to create a new object. Mouse interaction mode will automatically switch into control point placement mode.

3. Clock the down arrow of the control point place button in the Markups toolbar to select the "place multiple control points" checkbox to keep placing control points continuously, without the need to click the place button after each point.

4. Lift-click a slice view or 3D view to place points.

5. Double-left-click or right-click to finish point placement

Edit control positions in existing markups:
1. Make sure the correct markup is selected in the markups module or Markups toolbar.

2. Left-click and drag a control point to move it.

3. Left-click a control point to jump to it in all slice viewers. This helps in adjusting its position along all axes.

4. Right-click to delete or rename a control point or change markup properties.

5. Ctrl + Left-click to place a new control point on a markups curve.

6. Enable Display/Interaction/Visible to show a widget that allows translation/rotation of the entire widget.

Edit properties of a markup that is picked in a view: To pick a markup in a viewer so that its propeties can be edited in the Markups module, right click on it in a slice view or 3D view and choose "Edit properties."

Options available to edit Plane and ROI markups

Keyboard Shortcuts When Markups toolbar is displayed: Ctrl+Shift+A for creating a new markup, control+shift+T for toggling placing multiple points, and Control+Shift+spcae for placing a new control point

Plethora of display options

| **Section**                           | **Option / Control**                  | **Description / Function**                                                                                                                         |
| ------------------------------------- | ------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Interaction**                       | **Locked**                            | Toggles whether markups can be moved by mouse interactions, overriding individual control point locks.                                             |
|                                       | **Fixed list of points**              | Toggles ability to add/remove control points; positions can still be undefined.                                                                    |
|                                       | **Click to Jump Slices**              | Enables slice viewers to jump to a control point when clicked in the name column. Includes options for centering and using arrow keys to navigate. |
|                                       | **Show slice intersections**          | Shows or hides slice intersection lines in 2D views.                                                                                               |
| **Buttons (Apply to control points)** | **Toggle visibility flag**            | Toggles visibility for all control points (menu: all visible/invisible).                                                                           |
|                                       | **Toggle selected flag**              | Toggles selection state for all control points (menu: all selected/deselected).                                                                    |
|                                       | **Toggle lock flag**                  | Toggles lock state for all control points (menu: all locked/unlocked).                                                                             |
|                                       | **Skip highlighted control points**   | Sets highlighted control points‚Äô state to *Skip* (skipped during placement).                                                                       |
|                                       | **Clear highlighted control points**  | Clears highlighted points‚Äô position and sets state to *Clear*.                                                                                     |
|                                       | **Delete highlighted control points** | Deletes highlighted control points from the active list.                                                                                           |
|                                       | **Remove all control points**         | Deletes all control points in the active list (empties list).                                                                                      |
| **Display Options**                   | **Transformed**                       | Shows transformed coordinates (applying current transforms). Unchecked shows raw RAS values.                                                       |
|                                       | **Hide RAS**                          | Hides or shows coordinate columns (RAS). Right-click rows to view coordinates.                                                                     |
| **Control Points Table**              | **Context menu (right-click)**        | Options include: show full precision coordinates, measure distance, delete, jump to point, refocus 3D view, or copy/move point to another list.    |
| **Columns**                           | **Selected**                          | Checkbox indicating if control point is selected (click to toggle).                                                                                |
|                                       | **Locked**                            | Lock icon (open/closed padlock) indicating lock state; click to toggle.                                                                            |
|                                       | **Visibility**                        | Eye icon showing visibility state; click to toggle.                                                                                                |
|                                       | **Name**                              | Short name displayed next to glyphs in viewers.                                                                                                    |
|                                       | **Description**                       | Longer text description (not shown in viewers).                                                                                                    |
|                                       | **X, Y, Z**                           | RAS coordinates (3 decimal places shown).                                                                                                          |
|                                       | **State**                             | Displays current control point state (Edit, Skip, Restore, Clear); click to cycle through.                                                         |
| **State Definitions**                 | **Edit**                              | Control point is being placed; only one can be edited at a time.                                                                                   |
|                                       | **Skip**                              | Control point undefined; cannot be selected for placement.                                                                                         |
|                                       | **Restore**                           | Restores the last known position of the control point.                                                                                             |
|                                       | **Clear**                             | Control point not yet placed; available for placement.                                                                                             |
| **Advanced Section**                  | **Move Up**                           | Moves highlighted control point up one position in the list.                                                                                       |
|                                       | **Move Down**                         | Moves highlighted control point down one position in the list.                                                                                     |
|                                       | **Add Control Point**                 | Adds a new unplaced control point with undefined position.                                                                                         |
| **Naming**                            | **Name Format**                       | Format for naming new control points (`%N`=list name, `%d`=index).                                                                                 |
|                                       | **Apply**                             | Renames all control points based on current format; can be used to renumber points.                                                                |
|                                       | **Reset**                             | Resets name format to default `%N-%d`.                                                                                                             |
| **Conversion**                        | **Convert annotation fiducials**      | Converts annotation fiducials to markups and removes the original annotation nodes.                                                                |


Curve setting section: Curve type can be linear, spline, polynomial, or shrot distance on surface. Constrain to Model generates curve from control points and projects onto surface, except for shortest distance ons ruface curve type, the cot function is minimzed to find path connecting two control points.

Maximum projection distance provides max search radius tolerance defining the allowavle projection distance for projecting curve points. It is specified as  apercentage of the model's bounding box diagnoal in world coordinate system.

Resample:

Output node replces control points by curve points sampled at equal distances.
Constrain points to surface: If a model is selected, the resampled points projected to the chosen mdodel surface.
Max projection distance: As above

Plane and ROI settings options available. Also can create template landmarks.

Slicer API: Concepts and use

Slicer core infrastructure is mostly implemented in C++ and mde available in Python in the slicer namespace.

C++ classes are made available in Python using two mechanisms: PythonQt and VTK Python wrapper. They have a few slight differences:

Qt classes (class name starts with q or Q): for example, qSlicerMarkupsPlaceWidget. These classes are all derived from QObject and follow Qt conventions. They support properties, signals, and slots.

VTK classes (class name starts with vtk): for example, vtkMRMLModelDisplayNode. These classes are all derived from vtkObject and follow VTK conventions.

The documentation is generated using the Doxygen tool, which uses C++ documentation. Rules for intepreting documentation for Python:

Public member functions can be accessed as objectName.memberFunctionName(arguments). For example, a method of the slicer.mrmlScene object can be caled as slicer.mrmlScene,GetNumberOfNodesByClass('vtkMRMLTransformNode').

In QT classes, only methods that have Q_INVOKABLE keyword next to them ar eavailable from Python. 

virtual and override specifiers can be ignored as they just indicate that the method can be or is overridden in a child class.

className (for Qt classes): constructor, shows the arguments that can be passed when an object is cretaed. Qt objects can be instantiated using qt.QSomeObject(). For rexample myObj = qt.QComboBox()

New (for VTK classes): constructor, never needs an argument. VTK objects can be isntantiaed using vtk.vtkSomeObject(). e.g. myObj = vtk.vtkPolyData()

If a variable holds the last referenc eto an object, then it can be deleted by calling del or setting the variable to a new value. For example, del(myObj) or myObj=None.

Static Public Member Functions: can be accessed as slicer.className.memberFunctionName(arguments) for example: slicer.vtkMRMLModelDisplayNode.GetSliceDisplayModeAsString(0)

Properties (for Qt classes): these are values that are accessible as object attrributes in Python and can be read adn written as objectName.propertyName.

E.g. w = slicer.qSlicerMarkupsPlaceWidget()
w.deleteAllControlPointsOptionVisible
True
w.deleteAllControlPointsOptionVisible=False
w.deleteAllControlPointsOptionVisible
False

Public slots (for Qt classes): publicly available methods. Note that setSomeProperty methods show up in the documentaton but in Python these methods are nto available and instead property values can be set using someProperty = ...

Signals (for Qt classes): signals that can be connected to Python methods

def someFunction():
  print("clicked!")

b = qt.QPushButton("MyButton")
b.connect("clicked()", someFunction)  # someFunction will be called when the button is clicked
b.show()

Public Types: most commonly used for psecifying enumerated values (indicated by enum type). These values can be accessed as slicer.className.typeName, for example slicer.qSlicerMarkupsPlaceWidget.HidePlaceMultipleOption

Protected Slots, Member Functions, Attributes: for internal use only, not accessible in Python

Mapping commonly used data typs from C++ documentation to Python:

void -> Python: if the return value of a method is this type then it means that no value is returned
someClass* (object pointer) -> Python: since Python takes care of reference counting, it can simply be intepreted in Python as someClass. The called method can modify the object.
int, char, short (with optional signed or unsigned prefix) -> Python: int
float, double -> Python: float
double[3] -> Python: initialize a variable before the method call as pont = np.zeros(3) (or point = [0.0, 0.0, 0.0]) and use it as an argument in the function
const char *, std::string, QString, const QStrings -> Python: str
bool -> Pyton: bool

Slicer

UI

Slicer stores all loaded data in a repository called the "scene" (or Slicer scene or MRML scene). Each data set, such as an image volume, surface model, or point set, is represented in the scene as a node.

Slicer provides a large number of modules, each implementing a specific set of functions for creating or manipulating data in the scene. Modules typically do no tinteract with each other directly, all operating on the data nodes in the scene. Slicer package contains over 100 built-in modules an additional modules cna be installed by using the Extensions Manager.

Module Panel: This panel, located by default on the left side of the application main window, displays all the options and features that the current module ofers to the user. Current module can be selected using the Module Section toolbar.

Data Probe: Data Probe is located at the bottom of the module panel. It displays information about view content at the position of the mous pointer.

This information includes Slice view information displayed when the mouse is over a slice view, Volume layer information (three lines, one for each volume layer), and segmentation information (for each segmentation visible at that position)

Slice view information includes: slice view name, anatomical position, view orientation, and slice spacing

Volume layer information includes: layer type, Volume name, bolume voxel coordinates, and voxel value

Segmentation information includes layer type, segmentation name, and segment names.

Views

Slicer displays data in various views. The user can choose between a number of predefined layouts, which may contain slice, 3D, chart, and table views. The Layout Toolbar provides a drop-down menu of layouts useful for manu types of studies. When Slicer is exited normally, the selected layout is saved and resotrd next time the application is started.

Application Menu

File: Functions for laoading apreviously saved scene or individual datasets of various types, and for downloading sample datasets from the internet. An option for saving scens and data is also provided here. Add Data allows loading data from files. DOCOM module si recommended to import data from DICOM files and loading of imported DICOM data. Save opens the 'Save Data' window, which offers a variety of options fo savibng all data or selected datasets.

Edit: Contains an option for showing Application Settings, which allows users to customize appearance and behavior of Slicer, such as modules dislayed in the toolbar, application font size, temporar directory location, location of additional Slicer modules to include.

View: Functions fo showing/hiding additional windows and widgets, such as Extensions manager for instlling extensions from Slicer app store, Error Log for checking if the application encountered any potential errors, Python Console for getting a Python console to interact with the loaded data or modules, show/hide toolbars, or switch view layout.

Help: Contains links to documentation, guides, and community sites. Report a Bug provides instructions for bug reporting and convenient access to log messages. There are also links to search for Slier Publications and learn How to Cite Slicer.

Toolbar

Toolbar provides quick access to commonly used functions. Individual toolbar panels can be shown/hidden using Menu: View/Toolbars section.

Module Selection toolbar is used fo rselecting the currently active 'module.' The toolbar provides options fo searching for moldule names (Ctrl+f or click on magnify glass icon) or selecting from a menu. Module history dropdown button shows the list of reently used modules. Arrow buttons can be used for going back to.returning from previously used module.

Favorite modules toolbar contains a list of most frequently used modules. The list can be customized using menu: Edit/Application settings/Modules/Favorite Modules. Drag-and0drop modules from the Modules list ot the Favorite Modules list to add a module.

Status bar

This panel may display application status, such as current operation in progress. Clicking the little X icons displays the Error Log window.

Review Loaded Data

Data available in Slicer can be reviewed in the Data module, which can be found on the toolbar or the modules list.

The Data module's default Subject hierarchy tab can show the datasets in a tree hierarchy, arranged as patient/study/series as typical in DICOM, or any other folder structure.

The Subject hierarchy view contains numerous built-in functions for all types of data. These functions can be accessed by right-clicking the node in the tree. The list of actions differs for each data type, so it is useful to explore the options.

Selecting Displayed Data

Data module's Subject hierarchy shows all data sets in the sciene. Click the 'eye' icon to show/hide an item in all views. Drag-and-drop an item into a view to show it in that view.

Multiple items can be selected in the subject hierarchy tree using Ctrl-Left-Click or Shift-Left-Click and dragged at once into selected view. If two volumes ar edragged into a view at the same time they will be both shown, blended ogether.

If a view is displayed only in selected views, you can right-click on the item and select "Show in all views" to quickly show in all views.

If view link is enabled for a slice view thn dragging a volume to any of the views will show the volue in all views in that group.

Display options can be adjusted by right-clicking the eye icon in the display column of the tree. Note that these options ar edifferent from options offered when right-clicking on the "Node" or "Transform" column in the tree.

For volums, display options include reset field of view on show (if enabled, then shwoing a volume makes adjust vies to show the volume in the center, filling the field of view) and reset view orientation on show (if enabled, then showing a volume makes the slice views aligned with the volume axes).

Interacting with views:

View cross-reference: Holding down the Shift key while moving the mouse in any slice or 3D view will cause the crosshair to move to the selected position in all views. By default, when the crosshair is moved in any views, all slice views arre scrolled to the same RAS position indexed by the mouse. This feature is useful when inspecting.

To show/hide the Crosshair position, click crosshair icon.

To customize behavior and appearance of the Crosshair, click the ddown arrow button on the right side of the crosshair icon.

Transform mode is the default interaction mode. By default, Place mode persists for one ‚Äúplace‚Äù operation after the Place Mode icon is selected, and then the mode switches back to Transform. Place mode can be made persistent (useful for placing multiple control points) by checking the Persistent checkbox shown rightmost in the Mouse Mode Toolbar.

Module Overview
Types

Command Line Interface (CLI)

CLIs are standalone executables with a limited input/output arguments complexity (simple argument types, no user interactions). Recommended for implementing computational algorithms.
Slicer can run any command-line appliction from the GUI by providing an inteface description .xml file. Can be implemented in any language (C++, Python,...). Inputs and outputs specified in XML file, GUI is generated automatically. Parameters passed through command line and files. Run in a separate processing thread, can report progress and be aborted.

Things not supported: pass back with intermediate results, updating views while executing, acepting input while unning to steer the module, and requesting input while running.

Loadable Modules

Loadable modules are C++ plugins built against Slicer. They define custom GUIs for their specific behavior as they have full control over the application. Recommended for implemnting complex, performance-critical, interactive components, application infrastructrue (e.g., reusable of low-level GUI widgets).

Writtten in C++ and distributed as shared libraries. Full Slicer API is accessible. Full control over Slicer UI based on Qt and Slicer internals such as MRML, logics, display, managers, and more.

Scripted Modules

Scriptd Modules ar Python scripts using Slicer API. They define custom GUIs for their specific behaviro as they have full control over the application. Recommended for fast prototyping and custom workflow development.

Written in Python, full Slicer API is accessible, and full access to MRML, VTK, Qt, ITK, and SimplelITK APIs since those are Python wrapped.

FOR SCRIPTED MODULES: Download Slicer anc reate an initial skeleton using the extension Wizard adding a module of type scripted.

See the following links for more information:
---------------------------------------------------------------------------------------------------------------------
https://slicer.readthedocs.io/en/latest/developer_guide/extensions.html#extensions

https://training.slicer.org/#developer-tutorials

https://slicer.readthedocs.io/en/latest/developer_guide/python_faq.html

https://slicer.readthedocs.io/en/latest/developer_guide/script_repository.html

https://github.com/Slicer/Slicer/tree/main/Modules/Scripted
-----------------------------------------------------------------------------------------------------------------------

Association of MRML nodes to modules: Modules can be associated with MRML nodes, which for example allows dtermining what module can be used to edit a certain MRML node. A module can either specify the list of node types it supports by overriding qSlicerAbstractCoreModule::associatedNodeTypes() method or a module can call qSlicerCoreApplication::addModuleAssociatedNodeTypes() to associated any node type with any module.

Multiple modules can be associated with the same MRML node type. The best module fo editing a specific node instance is determined run-time. The application framework calls qSlicerAbstractModuleWidget::nodeEditable() for each associated module candidate and will activate the one that has the highest confidence in handling the node.

To select a MRML node as the 'active' or 'edited' node in a module the module widget's qSlicerAbstractModuleWidget::setEditedNode() method is called.



