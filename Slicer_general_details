Slicer's data model is built around a MRML scene, which is a graph of interconnected nodes. Each item in the Data module, such as subjects, studies, volumes, transforms, markups, modules,
and more is a MRML node. Nodes can reference each other. Examples: A volume node may be transformed by a transform node; a model might reference a scalar overlay volume; a segmentation can reference a master volume.

In the subject hierarchy, the subject is the top-level grouping, usually representing one patient.
Studies are optional layers often used for multiple imaging sessions.
Data nodes such as volumes and models are MRML nodes under the hierarchy.

Each hierarchy item may have references:
Parent/child relationships provide hierarchical organization in the Data tree; transform references define spatial relationships; and other child/parent node references exist,
such as segmentations referencing volumes, or models referencing transforms.

In the transform reference case, if node A is transformed by node B, nodeA's transformID is the ID of node B. When Slicer renders A, it applies transform B automatically.
When you remove a transform node, Slicer checks what nodes reference it; this is where highlighting helps. Highlight color visualizes dependency directionality. 

Green emphasizes items referencing the current item --> Incoming edges
Yellow "  "   "   "  " referenced by "   "  "   "  "  "   Outgoing " "
Light yellow "   "   " recursively referenced by the current item --> Deeper layers -- "What do I indirectly depend on"

Consider the following example:

Subject (Patient)
‚îî‚îÄ‚îÄ Study (Scan session)
     ‚îú‚îÄ‚îÄ Volume1          ‚Üê Data Node (original MRI scan)
     ‚îú‚îÄ‚îÄ Volume2          ‚Üê Data Node (registered MRI scan)
     ‚îú‚îÄ‚îÄ Segmentation1    ‚Üê Data Node (segmentation of Volume2)
     ‚îú‚îÄ‚îÄ Transform1       ‚Üê Transform Node (aligns Volume2 to Volume1)
     ‚îî‚îÄ‚îÄ Transform2       ‚Üê Transform Node (moves Transform1 to world space)

Segmentation1 (Data Node) ‚îÄ‚îÄ‚Üí Volume2 (Data Node) ‚îÄ‚îÄ‚Üí Transform1 (Transform Node) ‚îÄ‚îÄ‚Üí Transform2 (Transform Node)

Subject (Patient)
‚îî‚îÄ‚îÄ Study (Session)
     ‚îú‚îÄ‚îÄ üü© Segmentation1   ‚Üí  üü® Volume2  ‚Üí  üü® Transform1  ‚Üí  üü®‚óå Transform2
     ‚îÇ                          ‚Üë
     ‚îÇ                     Selected node
     ‚îÇ
     ‚îú‚îÄ‚îÄ Volume1  (unrelated, stays gray)
     ‚îî‚îÄ‚îÄ (All under Study)

In this example: Segmentation1 is based on Volume2 (referencing it as its master volume), Volume2 is transformed by Transform1, and Transform1 is transformed by Transform2 (a parent transform).

A plugin is any loadable, extensible component that adds functionality. Internally, msot are implemented as modules in Python or C++, or as plugins within modules.

| Type                                    | Purpose                                                               | Typical Examples                                           |
| --------------------------------------- | --------------------------------------------------------------------- | ---------------------------------------------------------- |
| **Loadable module (C++)**               | Performance-critical processing, visualization, IO                    | Volumes, Models, Segmentations, Transforms                 |
| **Scripted module (Python)**            | Custom logic and UI, fast development                                 | Segment Editor Effects, Registration plugins, AI inference |
| **CLI module (Command-Line Interface)** | Executes external command-line tools with standard I/O                | BRAINS registration, diffusion tools                       |
| **Subject hierarchy plugin**            | Extends how items appear in the Data module and how references behave | Subject hierarchy display rules, node type icons           |
| **DICOM plugin**                        | Adds support for new DICOM modalities or private tags                 | RT, PET, Ultrasound, etc.                                  |
| **Markups / Annotation plugins**        | Add new types of markups (points, curves, planes, ROI)                | Fiducials, Curve, Angle, ROI                               |
| **I/O plugins**                         | Add import/export support for new file formats                        | Custom 3D formats, medical device output                   |
| **Python scripted logic modules**       | Provide backend logic callable from Python                            | e.g., custom pipelines or AI preprocessing steps           |
| Module                | Purpose                                                                                     |
| --------------------- | ------------------------------------------------------------------------------------------- |
| **Data**              | Shows subject hierarchy and MRML nodes; handles references (the one you‚Äôve been analyzing). |
| **DICOM**             | Manages DICOM import/export, database, and plugins.                                         |
| **Transforms**        | Displays and edits transform nodes.                                                         |
| **Subject hierarchy** | Underlying logic for Data module hierarchy organization.                                    |
| Module                             | Purpose                                                  |
| ---------------------------------- | -------------------------------------------------------- |
| **Volumes**                        | Manages scalar and vector volumes, window/level display. |
| **Slice Viewer / 3D Viewer**       | Built-in display controls for visualization.             |
| **Volume Rendering**               | GPU volume rendering controls.                           |
| **Models**                         | Display and manage surface meshes (STL, OBJ, etc.).      |
| **Segmentations / Segment Editor** | Create, edit, and manage segmentation nodes.             |
| Module                                            | Purpose                                  |
| ------------------------------------------------- | ---------------------------------------- |
| **Transforms**                                    | View, edit, and combine transform nodes. |
| **Landmark Registration / Fiducial Registration** | Registration via markups.                |
| **General Registration (BRAINS)**                 | Advanced CLI-based registration.         |
| Module                 | Purpose                                         |
| ---------------------- | ----------------------------------------------- |
| **Label Statistics**   | Compute voxel counts and volumes for labelmaps. |
| **Segment Statistics** | Compute measurements for segmentations.         |
| **PET DICOM tools**    | Quantify SUV and related measures.              |
| Module                          | Purpose                                      |
| ------------------------------- | -------------------------------------------- |
| **Python Interactor**           | Console access to MRML scene and Python API. |
| **Sample Data**                 | Loads example datasets for testing.          |
| **Screen Capture / Animations** | Capture renderings for documentation.        |
| **Application Settings**        | System and display configuration.            |



| **Plugin Type**        | **Purpose / What It Does**                                                                                                | **Implementation (How to Make It)**                                                                                                                                                                                                                                                   | **Defines / Customizes**                                                                                                           | **Examples (Built-in or Extensions)**                                                                                                                                                       |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| üìù **Write Plugin**    | Adds or extends *data writing / export* capabilities for specific node types (e.g., saving special file formats).         | ‚Ä¢ Subclass of `qSlicerSubjectHierarchyAbstractPlugin` (C++) or `AbstractScriptedSubjectHierarchyPlugin` (Python).<br>‚Ä¢ Implement write logic in `writeData()` and define supported node types.<br>‚Ä¢ Register the plugin in the module‚Äôs `setup()` or `__init__()`.                    | ‚Ä¢ File type support<br>‚Ä¢ Export actions in context menu<br>‚Ä¢ Node-to-file mapping rules                                            | *Less common in core; examples appear in extensions that add export formats (e.g., SlicerRT for DICOM-RT, SlicerHeart for cardiac structures)*                                              |
| üß± **Role Plugin**     | Adds *support for new data node types* ‚Äî defines how they appear and behave in the Subject Hierarchy.                     | ‚Ä¢ Subclass `qSlicerSubjectHierarchyAbstractPlugin` (C++) or `AbstractScriptedSubjectHierarchyPlugin` (Python).<br>‚Ä¢ Implement node type ownership (`canOwnSubjectHierarchyItem`), icon, tooltip, visibility handling, help text, and display name.<br>‚Ä¢ Register during module setup. | ‚Ä¢ Ownership rules<br>‚Ä¢ Node icons and tooltips<br>‚Ä¢ Display visibility<br>‚Ä¢ Help text and edit properties<br>‚Ä¢ Displayed node name | **Core:** Markups, Models, SceneViews, Charts, Folder, Tables, Transforms, LabelMaps, Volumes<br>**Extensions:** Role plugin in *SlicerHeart* (cardiac nodes)                               |
| ‚öôÔ∏è **Function Plugin** | Adds *actions* (functions) to the **right-click context menu** for nodes or the scene ‚Äî allows custom operations on data. | ‚Ä¢ Subclass `qSlicerSubjectHierarchyAbstractPlugin` (C++) or `AbstractScriptedSubjectHierarchyPlugin` (Python).<br>‚Ä¢ Implement functions that define context menu actions (`nodeContextMenuActions`), specify applicable node types, and connect actions to logic.                     | ‚Ä¢ Context menu actions<br>‚Ä¢ Scene-level actions<br>‚Ä¢ Node-type filtering for actions<br>‚Ä¢ Action logic handlers                    | **Core:** CloneNode, ParseLocalData, Register, Segment, DICOM, Volumes, Markups, Models, Annotations, Segmentations, Segments<br>**Extensions:** Function plugin in *Segment Editor* module |

Markups Module: Used to create and edit markups (point list, line, angle, curve, closed curve, plane, ROI) and adjust their display properties.

Placing new markups (control points):
1. Toggle the Markups Toolbar in the Mouse Interaction toolbar to show/hide the Markups toolbar.

2. Using Markups toolbar, click markups type buttong to create a new object. Mouse interaction mode will automatically switch into control point placement mode.

3. Clock the down arrow of the control point place button in the Markups toolbar to select the "place multiple control points" checkbox to keep placing control points continuously, without the need to click the place button after each point.

4. Lift-click a slice view or 3D view to place points.

5. Double-left-click or right-click to finish point placement

Edit control positions in existing markups:
1. Make sure the correct markup is selected in the markups module or Markups toolbar.

2. Left-click and drag a control point to move it.

3. Left-click a control point to jump to it in all slice viewers. This helps in adjusting its position along all axes.

4. Right-click to delete or rename a control point or change markup properties.

5. Ctrl + Left-click to place a new control point on a markups curve.

6. Enable Display/Interaction/Visible to show a widget that allows translation/rotation of the entire widget.

Edit properties of a markup that is picked in a view: To pick a markup in a viewer so that its propeties can be edited in the Markups module, right click on it in a slice view or 3D view and choose "Edit properties."

Options available to edit Plane and ROI markups

Keyboard Shortcuts When Markups toolbar is displayed: Ctrl+Shift+A for creating a new markup, control+shift+T for toggling placing multiple points, and Control+Shift+spcae for placing a new control point

Plethora of display options

| **Section**                           | **Option / Control**                  | **Description / Function**                                                                                                                         |
| ------------------------------------- | ------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Interaction**                       | **Locked**                            | Toggles whether markups can be moved by mouse interactions, overriding individual control point locks.                                             |
|                                       | **Fixed list of points**              | Toggles ability to add/remove control points; positions can still be undefined.                                                                    |
|                                       | **Click to Jump Slices**              | Enables slice viewers to jump to a control point when clicked in the name column. Includes options for centering and using arrow keys to navigate. |
|                                       | **Show slice intersections**          | Shows or hides slice intersection lines in 2D views.                                                                                               |
| **Buttons (Apply to control points)** | **Toggle visibility flag**            | Toggles visibility for all control points (menu: all visible/invisible).                                                                           |
|                                       | **Toggle selected flag**              | Toggles selection state for all control points (menu: all selected/deselected).                                                                    |
|                                       | **Toggle lock flag**                  | Toggles lock state for all control points (menu: all locked/unlocked).                                                                             |
|                                       | **Skip highlighted control points**   | Sets highlighted control points‚Äô state to *Skip* (skipped during placement).                                                                       |
|                                       | **Clear highlighted control points**  | Clears highlighted points‚Äô position and sets state to *Clear*.                                                                                     |
|                                       | **Delete highlighted control points** | Deletes highlighted control points from the active list.                                                                                           |
|                                       | **Remove all control points**         | Deletes all control points in the active list (empties list).                                                                                      |
| **Display Options**                   | **Transformed**                       | Shows transformed coordinates (applying current transforms). Unchecked shows raw RAS values.                                                       |
|                                       | **Hide RAS**                          | Hides or shows coordinate columns (RAS). Right-click rows to view coordinates.                                                                     |
| **Control Points Table**              | **Context menu (right-click)**        | Options include: show full precision coordinates, measure distance, delete, jump to point, refocus 3D view, or copy/move point to another list.    |
| **Columns**                           | **Selected**                          | Checkbox indicating if control point is selected (click to toggle).                                                                                |
|                                       | **Locked**                            | Lock icon (open/closed padlock) indicating lock state; click to toggle.                                                                            |
|                                       | **Visibility**                        | Eye icon showing visibility state; click to toggle.                                                                                                |
|                                       | **Name**                              | Short name displayed next to glyphs in viewers.                                                                                                    |
|                                       | **Description**                       | Longer text description (not shown in viewers).                                                                                                    |
|                                       | **X, Y, Z**                           | RAS coordinates (3 decimal places shown).                                                                                                          |
|                                       | **State**                             | Displays current control point state (Edit, Skip, Restore, Clear); click to cycle through.                                                         |
| **State Definitions**                 | **Edit**                              | Control point is being placed; only one can be edited at a time.                                                                                   |
|                                       | **Skip**                              | Control point undefined; cannot be selected for placement.                                                                                         |
|                                       | **Restore**                           | Restores the last known position of the control point.                                                                                             |
|                                       | **Clear**                             | Control point not yet placed; available for placement.                                                                                             |
| **Advanced Section**                  | **Move Up**                           | Moves highlighted control point up one position in the list.                                                                                       |
|                                       | **Move Down**                         | Moves highlighted control point down one position in the list.                                                                                     |
|                                       | **Add Control Point**                 | Adds a new unplaced control point with undefined position.                                                                                         |
| **Naming**                            | **Name Format**                       | Format for naming new control points (`%N`=list name, `%d`=index).                                                                                 |
|                                       | **Apply**                             | Renames all control points based on current format; can be used to renumber points.                                                                |
|                                       | **Reset**                             | Resets name format to default `%N-%d`.                                                                                                             |
| **Conversion**                        | **Convert annotation fiducials**      | Converts annotation fiducials to markups and removes the original annotation nodes.                                                                |


Curve setting section: Curve type can be linear, spline, polynomial, or shrot distance on surface. Constrain to Model generates curve from control points and projects onto surface, except for shortest distance ons ruface curve type, the cot function is minimzed to find path connecting two control points.

Maximum projection distance provides max search radius tolerance defining the allowavle projection distance for projecting curve points. It is specified as  apercentage of the model's bounding box diagnoal in world coordinate system.

Resample:

Output node replces control points by curve points sampled at equal distances.
Constrain points to surface: If a model is selected, the resampled points projected to the chosen mdodel surface.
Max projection distance: As above

Plane and ROI settings options available. Also can create template landmarks.

Slicer API: Concepts and use

Slicer core infrastructure is mostly implemented in C++ and mde available in Python in the slicer namespace.

C++ classes are made available in Python using two mechanisms: PythonQt and VTK Python wrapper. They have a few slight differences:

Qt classes (class name starts with q or Q): for example, qSlicerMarkupsPlaceWidget. These classes are all derived from QObject and follow Qt conventions. They support properties, signals, and slots.

VTK classes (class name starts with vtk): for example, vtkMRMLModelDisplayNode. These classes are all derived from vtkObject and follow VTK conventions.

The documentation is generated using the Doxygen tool, which uses C++ documentation. Rules for intepreting documentation for Python:

Public member functions can be accessed as objectName.memberFunctionName(arguments). For example, a method of the slicer.mrmlScene object can be caled as slicer.mrmlScene,GetNumberOfNodesByClass('vtkMRMLTransformNode').

In QT classes, only methods that have Q_INVOKABLE keyword next to them ar eavailable from Python. 

virtual and override specifiers can be ignored as they just indicate that the method can be or is overridden in a child class.

className...
